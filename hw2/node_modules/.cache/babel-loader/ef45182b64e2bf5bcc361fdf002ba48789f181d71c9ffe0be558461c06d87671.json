{"ast":null,"code":"// 方向向量\nconst DIRECTION_VECTORS = {\n  up: {\n    row: -1,\n    col: 0\n  },\n  down: {\n    row: 1,\n    col: 0\n  },\n  left: {\n    row: 0,\n    col: -1\n  },\n  right: {\n    row: 0,\n    col: 1\n  }\n};\n\n// 將位置轉換為字串 key\nexport function positionToKey(pos) {\n  return `${pos.row},${pos.col}`;\n}\n\n// 將字串 key 轉換為位置\nexport function keyToPosition(key) {\n  const [row, col] = key.split(',').map(Number);\n  return {\n    row,\n    col\n  };\n}\n\n// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos, gridSize) {\n  return pos.row >= 0 && pos.row < gridSize[0] && pos.col >= 0 && pos.col < gridSize[1];\n}\n\n// 檢查位置是否為障礙物\nexport function isObstacle(pos, obstacles) {\n  return obstacles.some(obs => obs.row === pos.row && obs.col === pos.col);\n}\n\n// 根據方向排序方塊位置（用於確定移動順序）\nexport function sortPositionsByDirection(positions, direction) {\n  const sorted = [...positions];\n  switch (direction) {\n    case 'left':\n      // 從左到右（欄位座標由小到大）\n      return sorted.sort((a, b) => a.col - b.col);\n    case 'right':\n      // 從右到左（欄位座標由大到小）\n      return sorted.sort((a, b) => b.col - a.col);\n    case 'up':\n      // 從上到下（行座標由小到大）\n      return sorted.sort((a, b) => a.row - b.row);\n    case 'down':\n      // 從下到上（行座標由大到小）\n      return sorted.sort((a, b) => b.row - a.row);\n    default:\n      return sorted;\n  }\n}\n\n// 計算方塊在指定方向能移動到的位置\nexport function calculateBlockPosition(startPos, direction, gridSize, obstacles, stoppedPositions) {\n  const vector = DIRECTION_VECTORS[direction];\n  let currentPos = {\n    ...startPos\n  };\n  while (true) {\n    const nextPos = {\n      row: currentPos.row + vector.row,\n      col: currentPos.col + vector.col\n    };\n\n    // 檢查是否超出地圖範圍\n    if (!isPositionValid(nextPos, gridSize)) {\n      break;\n    }\n\n    // 檢查是否撞到固定障礙物\n    if (isObstacle(nextPos, obstacles)) {\n      break;\n    }\n\n    // 檢查是否撞到已停下的方塊\n    if (stoppedPositions.has(positionToKey(nextPos))) {\n      break;\n    }\n    currentPos = nextPos;\n  }\n  return currentPos;\n}\n\n// 執行一次移動\nexport function executeMove(gameState, direction) {\n  const {\n    currentLevel,\n    blockPositions,\n    coveredCells,\n    currentTurn\n  } = gameState;\n  const {\n    gridSize,\n    obstacles\n  } = currentLevel;\n\n  // 建立固定障礙物集合\n  const staticObstacles = obstacles;\n\n  // 根據方向排序方塊\n  const sortedPositions = sortPositionsByDirection(blockPositions, direction);\n\n  // 追蹤已停下的方塊位置\n  const stoppedPositions = new Set();\n  const newPositions = [];\n\n  // 按順序處理每個方塊\n  for (const originalPos of sortedPositions) {\n    const newPos = calculateBlockPosition(originalPos, direction, gridSize, staticObstacles, stoppedPositions);\n    newPositions.push(newPos);\n    stoppedPositions.add(positionToKey(newPos));\n  }\n\n  // 更新覆蓋的格子\n  const newCoveredCells = new Set(coveredCells);\n  newPositions.forEach(pos => {\n    newCoveredCells.add(positionToKey(pos));\n  });\n\n  // 檢查是否勝利\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  const isGameWon = newCoveredCells.size >= targetCells;\n\n  // 檢查是否失敗\n  const isGameLost = !isGameWon && currentTurn >= currentLevel.turnLimit;\n\n  // 更新移動歷史\n  const newMoveHistory = [...gameState.moveHistory, newPositions];\n  return {\n    ...gameState,\n    blockPositions: newPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: currentTurn + 1,\n    isGameWon,\n    isGameLost,\n    moveHistory: newMoveHistory\n  };\n}\n\n// 計算覆蓋率\nexport function calculateCoverage(gameState) {\n  const {\n    currentLevel,\n    coveredCells\n  } = gameState;\n  const {\n    gridSize,\n    obstacles\n  } = currentLevel;\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  return Math.round(coveredCells.size / targetCells * 100);\n}\n\n// 計算星級評分\nexport function calculateStarRating(gameState) {\n  const {\n    currentLevel,\n    currentTurn\n  } = gameState;\n  const {\n    minSteps\n  } = currentLevel;\n  const movesUsed = currentTurn - 1; // 因為 currentTurn 是下一回合的數字\n\n  if (movesUsed <= minSteps + 1) {\n    return {\n      stars: 3,\n      description: '完美！'\n    };\n  } else if (movesUsed <= minSteps + 5) {\n    return {\n      stars: 2,\n      description: '很好！'\n    };\n  } else {\n    return {\n      stars: 1,\n      description: '完成！'\n    };\n  }\n}\n\n// 初始化遊戲狀態\nexport function initializeGameState(level) {\n  const initialCoveredCells = new Set();\n\n  // 初始方塊位置視為已覆蓋\n  level.blocks.forEach(block => {\n    initialCoveredCells.add(positionToKey(block));\n  });\n  return {\n    currentLevel: level,\n    blockPositions: [...level.blocks],\n    coveredCells: initialCoveredCells,\n    currentTurn: 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: [level.blocks]\n  };\n}\n\n// 撤銷移動\nexport function undoMove(gameState) {\n  if (gameState.moveHistory.length <= 1) {\n    return gameState; // 無法撤銷\n  }\n  const newMoveHistory = gameState.moveHistory.slice(0, -1);\n  const previousPositions = newMoveHistory[newMoveHistory.length - 1];\n\n  // 重新計算覆蓋的格子\n  const newCoveredCells = new Set();\n  previousPositions.forEach(pos => {\n    newCoveredCells.add(positionToKey(pos));\n  });\n  return {\n    ...gameState,\n    blockPositions: previousPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: gameState.currentTurn - 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: newMoveHistory\n  };\n}","map":{"version":3,"names":["DIRECTION_VECTORS","up","row","col","down","left","right","positionToKey","pos","keyToPosition","key","split","map","Number","isPositionValid","gridSize","isObstacle","obstacles","some","obs","sortPositionsByDirection","positions","direction","sorted","sort","a","b","calculateBlockPosition","startPos","stoppedPositions","vector","currentPos","nextPos","has","executeMove","gameState","currentLevel","blockPositions","coveredCells","currentTurn","staticObstacles","sortedPositions","Set","newPositions","originalPos","newPos","push","add","newCoveredCells","forEach","totalCells","obstacleCount","length","targetCells","isGameWon","size","isGameLost","turnLimit","newMoveHistory","moveHistory","calculateCoverage","Math","round","calculateStarRating","minSteps","movesUsed","stars","description","initializeGameState","level","initialCoveredCells","blocks","block","undoMove","slice","previousPositions"],"sources":["/Users/arthurlin/Desktop/網服/wp1141/hw2/src/utils/GameLogic.ts"],"sourcesContent":["import { Position, Direction, GameState, Level } from '../types/GameTypes';\n\n// 方向向量\nconst DIRECTION_VECTORS: Record<Direction, Position> = {\n  up: { row: -1, col: 0 },\n  down: { row: 1, col: 0 },\n  left: { row: 0, col: -1 },\n  right: { row: 0, col: 1 }\n};\n\n// 將位置轉換為字串 key\nexport function positionToKey(pos: Position): string {\n  return `${pos.row},${pos.col}`;\n}\n\n// 將字串 key 轉換為位置\nexport function keyToPosition(key: string): Position {\n  const [row, col] = key.split(',').map(Number);\n  return { row, col };\n}\n\n// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos: Position, gridSize: [number, number]): boolean {\n  return pos.row >= 0 && pos.row < gridSize[0] && pos.col >= 0 && pos.col < gridSize[1];\n}\n\n// 檢查位置是否為障礙物\nexport function isObstacle(pos: Position, obstacles: Position[]): boolean {\n  return obstacles.some(obs => obs.row === pos.row && obs.col === pos.col);\n}\n\n// 根據方向排序方塊位置（用於確定移動順序）\nexport function sortPositionsByDirection(positions: Position[], direction: Direction): Position[] {\n  const sorted = [...positions];\n  \n  switch (direction) {\n    case 'left':\n      // 從左到右（欄位座標由小到大）\n      return sorted.sort((a, b) => a.col - b.col);\n    case 'right':\n      // 從右到左（欄位座標由大到小）\n      return sorted.sort((a, b) => b.col - a.col);\n    case 'up':\n      // 從上到下（行座標由小到大）\n      return sorted.sort((a, b) => a.row - b.row);\n    case 'down':\n      // 從下到上（行座標由大到小）\n      return sorted.sort((a, b) => b.row - a.row);\n    default:\n      return sorted;\n  }\n}\n\n// 計算方塊在指定方向能移動到的位置\nexport function calculateBlockPosition(\n  startPos: Position,\n  direction: Direction,\n  gridSize: [number, number],\n  obstacles: Position[],\n  stoppedPositions: Set<string>\n): Position {\n  const vector = DIRECTION_VECTORS[direction];\n  let currentPos = { ...startPos };\n  \n  while (true) {\n    const nextPos: Position = {\n      row: currentPos.row + vector.row,\n      col: currentPos.col + vector.col\n    };\n    \n    // 檢查是否超出地圖範圍\n    if (!isPositionValid(nextPos, gridSize)) {\n      break;\n    }\n    \n    // 檢查是否撞到固定障礙物\n    if (isObstacle(nextPos, obstacles)) {\n      break;\n    }\n    \n    // 檢查是否撞到已停下的方塊\n    if (stoppedPositions.has(positionToKey(nextPos))) {\n      break;\n    }\n    \n    currentPos = nextPos;\n  }\n  \n  return currentPos;\n}\n\n// 執行一次移動\nexport function executeMove(\n  gameState: GameState,\n  direction: Direction\n): GameState {\n  const { currentLevel, blockPositions, coveredCells, currentTurn } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  // 建立固定障礙物集合\n  const staticObstacles = obstacles;\n  \n  // 根據方向排序方塊\n  const sortedPositions = sortPositionsByDirection(blockPositions, direction);\n  \n  // 追蹤已停下的方塊位置\n  const stoppedPositions = new Set<string>();\n  const newPositions: Position[] = [];\n  \n  // 按順序處理每個方塊\n  for (const originalPos of sortedPositions) {\n    const newPos = calculateBlockPosition(\n      originalPos,\n      direction,\n      gridSize,\n      staticObstacles,\n      stoppedPositions\n    );\n    \n    newPositions.push(newPos);\n    stoppedPositions.add(positionToKey(newPos));\n  }\n  \n  // 更新覆蓋的格子\n  const newCoveredCells = new Set(coveredCells);\n  newPositions.forEach(pos => {\n    newCoveredCells.add(positionToKey(pos));\n  });\n  \n  // 檢查是否勝利\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  const isGameWon = newCoveredCells.size >= targetCells;\n  \n  // 檢查是否失敗\n  const isGameLost = !isGameWon && currentTurn >= currentLevel.turnLimit;\n  \n  // 更新移動歷史\n  const newMoveHistory = [...gameState.moveHistory, newPositions];\n  \n  return {\n    ...gameState,\n    blockPositions: newPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: currentTurn + 1,\n    isGameWon,\n    isGameLost,\n    moveHistory: newMoveHistory\n  };\n}\n\n// 計算覆蓋率\nexport function calculateCoverage(gameState: GameState): number {\n  const { currentLevel, coveredCells } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  \n  return Math.round((coveredCells.size / targetCells) * 100);\n}\n\n// 計算星級評分\nexport function calculateStarRating(gameState: GameState): { stars: 1 | 2 | 3; description: string } {\n  const { currentLevel, currentTurn } = gameState;\n  const { minSteps } = currentLevel;\n  \n  const movesUsed = currentTurn - 1; // 因為 currentTurn 是下一回合的數字\n  \n  if (movesUsed <= minSteps + 1) {\n    return { stars: 3, description: '完美！' };\n  } else if (movesUsed <= minSteps + 5) {\n    return { stars: 2, description: '很好！' };\n  } else {\n    return { stars: 1, description: '完成！' };\n  }\n}\n\n// 初始化遊戲狀態\nexport function initializeGameState(level: Level): GameState {\n  const initialCoveredCells = new Set<string>();\n  \n  // 初始方塊位置視為已覆蓋\n  level.blocks.forEach(block => {\n    initialCoveredCells.add(positionToKey(block));\n  });\n  \n  return {\n    currentLevel: level,\n    blockPositions: [...level.blocks],\n    coveredCells: initialCoveredCells,\n    currentTurn: 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: [level.blocks]\n  };\n}\n\n// 撤銷移動\nexport function undoMove(gameState: GameState): GameState {\n  if (gameState.moveHistory.length <= 1) {\n    return gameState; // 無法撤銷\n  }\n  \n  const newMoveHistory = gameState.moveHistory.slice(0, -1);\n  const previousPositions = newMoveHistory[newMoveHistory.length - 1];\n  \n  // 重新計算覆蓋的格子\n  const newCoveredCells = new Set<string>();\n  previousPositions.forEach(pos => {\n    newCoveredCells.add(positionToKey(pos));\n  });\n  \n  return {\n    ...gameState,\n    blockPositions: previousPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: gameState.currentTurn - 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: newMoveHistory\n  };\n}\n"],"mappings":"AAEA;AACA,MAAMA,iBAA8C,GAAG;EACrDC,EAAE,EAAE;IAAEC,GAAG,EAAE,CAAC,CAAC;IAAEC,GAAG,EAAE;EAAE,CAAC;EACvBC,IAAI,EAAE;IAAEF,GAAG,EAAE,CAAC;IAAEC,GAAG,EAAE;EAAE,CAAC;EACxBE,IAAI,EAAE;IAAEH,GAAG,EAAE,CAAC;IAAEC,GAAG,EAAE,CAAC;EAAE,CAAC;EACzBG,KAAK,EAAE;IAAEJ,GAAG,EAAE,CAAC;IAAEC,GAAG,EAAE;EAAE;AAC1B,CAAC;;AAED;AACA,OAAO,SAASI,aAAaA,CAACC,GAAa,EAAU;EACnD,OAAO,GAAGA,GAAG,CAACN,GAAG,IAAIM,GAAG,CAACL,GAAG,EAAE;AAChC;;AAEA;AACA,OAAO,SAASM,aAAaA,CAACC,GAAW,EAAY;EACnD,MAAM,CAACR,GAAG,EAAEC,GAAG,CAAC,GAAGO,GAAG,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC;EAC7C,OAAO;IAAEX,GAAG;IAAEC;EAAI,CAAC;AACrB;;AAEA;AACA,OAAO,SAASW,eAAeA,CAACN,GAAa,EAAEO,QAA0B,EAAW;EAClF,OAAOP,GAAG,CAACN,GAAG,IAAI,CAAC,IAAIM,GAAG,CAACN,GAAG,GAAGa,QAAQ,CAAC,CAAC,CAAC,IAAIP,GAAG,CAACL,GAAG,IAAI,CAAC,IAAIK,GAAG,CAACL,GAAG,GAAGY,QAAQ,CAAC,CAAC,CAAC;AACvF;;AAEA;AACA,OAAO,SAASC,UAAUA,CAACR,GAAa,EAAES,SAAqB,EAAW;EACxE,OAAOA,SAAS,CAACC,IAAI,CAACC,GAAG,IAAIA,GAAG,CAACjB,GAAG,KAAKM,GAAG,CAACN,GAAG,IAAIiB,GAAG,CAAChB,GAAG,KAAKK,GAAG,CAACL,GAAG,CAAC;AAC1E;;AAEA;AACA,OAAO,SAASiB,wBAAwBA,CAACC,SAAqB,EAAEC,SAAoB,EAAc;EAChG,MAAMC,MAAM,GAAG,CAAC,GAAGF,SAAS,CAAC;EAE7B,QAAQC,SAAS;IACf,KAAK,MAAM;MACT;MACA,OAAOC,MAAM,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACtB,GAAG,GAAGuB,CAAC,CAACvB,GAAG,CAAC;IAC7C,KAAK,OAAO;MACV;MACA,OAAOoB,MAAM,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACvB,GAAG,GAAGsB,CAAC,CAACtB,GAAG,CAAC;IAC7C,KAAK,IAAI;MACP;MACA,OAAOoB,MAAM,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACvB,GAAG,GAAGwB,CAAC,CAACxB,GAAG,CAAC;IAC7C,KAAK,MAAM;MACT;MACA,OAAOqB,MAAM,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACxB,GAAG,GAAGuB,CAAC,CAACvB,GAAG,CAAC;IAC7C;MACE,OAAOqB,MAAM;EACjB;AACF;;AAEA;AACA,OAAO,SAASI,sBAAsBA,CACpCC,QAAkB,EAClBN,SAAoB,EACpBP,QAA0B,EAC1BE,SAAqB,EACrBY,gBAA6B,EACnB;EACV,MAAMC,MAAM,GAAG9B,iBAAiB,CAACsB,SAAS,CAAC;EAC3C,IAAIS,UAAU,GAAG;IAAE,GAAGH;EAAS,CAAC;EAEhC,OAAO,IAAI,EAAE;IACX,MAAMI,OAAiB,GAAG;MACxB9B,GAAG,EAAE6B,UAAU,CAAC7B,GAAG,GAAG4B,MAAM,CAAC5B,GAAG;MAChCC,GAAG,EAAE4B,UAAU,CAAC5B,GAAG,GAAG2B,MAAM,CAAC3B;IAC/B,CAAC;;IAED;IACA,IAAI,CAACW,eAAe,CAACkB,OAAO,EAAEjB,QAAQ,CAAC,EAAE;MACvC;IACF;;IAEA;IACA,IAAIC,UAAU,CAACgB,OAAO,EAAEf,SAAS,CAAC,EAAE;MAClC;IACF;;IAEA;IACA,IAAIY,gBAAgB,CAACI,GAAG,CAAC1B,aAAa,CAACyB,OAAO,CAAC,CAAC,EAAE;MAChD;IACF;IAEAD,UAAU,GAAGC,OAAO;EACtB;EAEA,OAAOD,UAAU;AACnB;;AAEA;AACA,OAAO,SAASG,WAAWA,CACzBC,SAAoB,EACpBb,SAAoB,EACT;EACX,MAAM;IAAEc,YAAY;IAAEC,cAAc;IAAEC,YAAY;IAAEC;EAAY,CAAC,GAAGJ,SAAS;EAC7E,MAAM;IAAEpB,QAAQ;IAAEE;EAAU,CAAC,GAAGmB,YAAY;;EAE5C;EACA,MAAMI,eAAe,GAAGvB,SAAS;;EAEjC;EACA,MAAMwB,eAAe,GAAGrB,wBAAwB,CAACiB,cAAc,EAAEf,SAAS,CAAC;;EAE3E;EACA,MAAMO,gBAAgB,GAAG,IAAIa,GAAG,CAAS,CAAC;EAC1C,MAAMC,YAAwB,GAAG,EAAE;;EAEnC;EACA,KAAK,MAAMC,WAAW,IAAIH,eAAe,EAAE;IACzC,MAAMI,MAAM,GAAGlB,sBAAsB,CACnCiB,WAAW,EACXtB,SAAS,EACTP,QAAQ,EACRyB,eAAe,EACfX,gBACF,CAAC;IAEDc,YAAY,CAACG,IAAI,CAACD,MAAM,CAAC;IACzBhB,gBAAgB,CAACkB,GAAG,CAACxC,aAAa,CAACsC,MAAM,CAAC,CAAC;EAC7C;;EAEA;EACA,MAAMG,eAAe,GAAG,IAAIN,GAAG,CAACJ,YAAY,CAAC;EAC7CK,YAAY,CAACM,OAAO,CAACzC,GAAG,IAAI;IAC1BwC,eAAe,CAACD,GAAG,CAACxC,aAAa,CAACC,GAAG,CAAC,CAAC;EACzC,CAAC,CAAC;;EAEF;EACA,MAAM0C,UAAU,GAAGnC,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;EAC5C,MAAMoC,aAAa,GAAGlC,SAAS,CAACmC,MAAM;EACtC,MAAMC,WAAW,GAAGH,UAAU,GAAGC,aAAa;EAC9C,MAAMG,SAAS,GAAGN,eAAe,CAACO,IAAI,IAAIF,WAAW;;EAErD;EACA,MAAMG,UAAU,GAAG,CAACF,SAAS,IAAIf,WAAW,IAAIH,YAAY,CAACqB,SAAS;;EAEtE;EACA,MAAMC,cAAc,GAAG,CAAC,GAAGvB,SAAS,CAACwB,WAAW,EAAEhB,YAAY,CAAC;EAE/D,OAAO;IACL,GAAGR,SAAS;IACZE,cAAc,EAAEM,YAAY;IAC5BL,YAAY,EAAEU,eAAe;IAC7BT,WAAW,EAAEA,WAAW,GAAG,CAAC;IAC5Be,SAAS;IACTE,UAAU;IACVG,WAAW,EAAED;EACf,CAAC;AACH;;AAEA;AACA,OAAO,SAASE,iBAAiBA,CAACzB,SAAoB,EAAU;EAC9D,MAAM;IAAEC,YAAY;IAAEE;EAAa,CAAC,GAAGH,SAAS;EAChD,MAAM;IAAEpB,QAAQ;IAAEE;EAAU,CAAC,GAAGmB,YAAY;EAE5C,MAAMc,UAAU,GAAGnC,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;EAC5C,MAAMoC,aAAa,GAAGlC,SAAS,CAACmC,MAAM;EACtC,MAAMC,WAAW,GAAGH,UAAU,GAAGC,aAAa;EAE9C,OAAOU,IAAI,CAACC,KAAK,CAAExB,YAAY,CAACiB,IAAI,GAAGF,WAAW,GAAI,GAAG,CAAC;AAC5D;;AAEA;AACA,OAAO,SAASU,mBAAmBA,CAAC5B,SAAoB,EAA6C;EACnG,MAAM;IAAEC,YAAY;IAAEG;EAAY,CAAC,GAAGJ,SAAS;EAC/C,MAAM;IAAE6B;EAAS,CAAC,GAAG5B,YAAY;EAEjC,MAAM6B,SAAS,GAAG1B,WAAW,GAAG,CAAC,CAAC,CAAC;;EAEnC,IAAI0B,SAAS,IAAID,QAAQ,GAAG,CAAC,EAAE;IAC7B,OAAO;MAAEE,KAAK,EAAE,CAAC;MAAEC,WAAW,EAAE;IAAM,CAAC;EACzC,CAAC,MAAM,IAAIF,SAAS,IAAID,QAAQ,GAAG,CAAC,EAAE;IACpC,OAAO;MAAEE,KAAK,EAAE,CAAC;MAAEC,WAAW,EAAE;IAAM,CAAC;EACzC,CAAC,MAAM;IACL,OAAO;MAAED,KAAK,EAAE,CAAC;MAAEC,WAAW,EAAE;IAAM,CAAC;EACzC;AACF;;AAEA;AACA,OAAO,SAASC,mBAAmBA,CAACC,KAAY,EAAa;EAC3D,MAAMC,mBAAmB,GAAG,IAAI5B,GAAG,CAAS,CAAC;;EAE7C;EACA2B,KAAK,CAACE,MAAM,CAACtB,OAAO,CAACuB,KAAK,IAAI;IAC5BF,mBAAmB,CAACvB,GAAG,CAACxC,aAAa,CAACiE,KAAK,CAAC,CAAC;EAC/C,CAAC,CAAC;EAEF,OAAO;IACLpC,YAAY,EAAEiC,KAAK;IACnBhC,cAAc,EAAE,CAAC,GAAGgC,KAAK,CAACE,MAAM,CAAC;IACjCjC,YAAY,EAAEgC,mBAAmB;IACjC/B,WAAW,EAAE,CAAC;IACde,SAAS,EAAE,KAAK;IAChBE,UAAU,EAAE,KAAK;IACjBG,WAAW,EAAE,CAACU,KAAK,CAACE,MAAM;EAC5B,CAAC;AACH;;AAEA;AACA,OAAO,SAASE,QAAQA,CAACtC,SAAoB,EAAa;EACxD,IAAIA,SAAS,CAACwB,WAAW,CAACP,MAAM,IAAI,CAAC,EAAE;IACrC,OAAOjB,SAAS,CAAC,CAAC;EACpB;EAEA,MAAMuB,cAAc,GAAGvB,SAAS,CAACwB,WAAW,CAACe,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACzD,MAAMC,iBAAiB,GAAGjB,cAAc,CAACA,cAAc,CAACN,MAAM,GAAG,CAAC,CAAC;;EAEnE;EACA,MAAMJ,eAAe,GAAG,IAAIN,GAAG,CAAS,CAAC;EACzCiC,iBAAiB,CAAC1B,OAAO,CAACzC,GAAG,IAAI;IAC/BwC,eAAe,CAACD,GAAG,CAACxC,aAAa,CAACC,GAAG,CAAC,CAAC;EACzC,CAAC,CAAC;EAEF,OAAO;IACL,GAAG2B,SAAS;IACZE,cAAc,EAAEsC,iBAAiB;IACjCrC,YAAY,EAAEU,eAAe;IAC7BT,WAAW,EAAEJ,SAAS,CAACI,WAAW,GAAG,CAAC;IACtCe,SAAS,EAAE,KAAK;IAChBE,UAAU,EAAE,KAAK;IACjBG,WAAW,EAAED;EACf,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
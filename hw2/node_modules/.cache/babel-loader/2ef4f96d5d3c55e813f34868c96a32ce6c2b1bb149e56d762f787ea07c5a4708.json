{"ast":null,"code":"import _objectSpread from\"/Users/arthurlin/Desktop/\\u7DB2\\u670D/wp1141/hw2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// 方向向量\nconst DIRECTION_VECTORS={up:{row:-1,col:0},down:{row:1,col:0},left:{row:0,col:-1},right:{row:0,col:1}};// 將位置轉換為字串 key\nexport function positionToKey(pos){return\"\".concat(pos.row,\",\").concat(pos.col);}// 將字串 key 轉換為位置\nexport function keyToPosition(key){const[row,col]=key.split(',').map(Number);return{row,col};}// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos,gridSize){return pos.row>=0&&pos.row<gridSize[0]&&pos.col>=0&&pos.col<gridSize[1];}// 檢查位置是否為障礙物\nexport function isObstacle(pos,obstacles){return obstacles.some(obs=>obs.row===pos.row&&obs.col===pos.col);}// 根據方向排序方塊位置（用於確定移動順序）\nexport function sortPositionsByDirection(positions,direction){const sorted=[...positions];switch(direction){case'left':// 從左到右（欄位座標由小到大）\nreturn sorted.sort((a,b)=>a.col-b.col);case'right':// 從右到左（欄位座標由大到小）\nreturn sorted.sort((a,b)=>b.col-a.col);case'up':// 從上到下（行座標由小到大）\nreturn sorted.sort((a,b)=>a.row-b.row);case'down':// 從下到上（行座標由大到小）\nreturn sorted.sort((a,b)=>b.row-a.row);default:return sorted;}}// 計算方塊在指定方向能移動到的位置，並返回經過的所有格子\nexport function calculateBlockMovement(startPos,direction,gridSize,obstacles,stoppedPositions){const vector=DIRECTION_VECTORS[direction];let currentPos=_objectSpread({},startPos);const pathCells=[_objectSpread({},startPos)];// 包含起始位置\nwhile(true){const nextPos={row:currentPos.row+vector.row,col:currentPos.col+vector.col};// 檢查是否超出地圖範圍\nif(!isPositionValid(nextPos,gridSize)){break;}// 檢查是否撞到固定障礙物\nif(isObstacle(nextPos,obstacles)){break;}// 檢查是否撞到已停下的方塊\nif(stoppedPositions.has(positionToKey(nextPos))){break;}currentPos=nextPos;pathCells.push(_objectSpread({},currentPos));}return{finalPosition:currentPos,pathCells};}// 執行一次移動\nexport function executeMove(gameState,direction){const{currentLevel,blockPositions,coveredCells,currentTurn}=gameState;const{gridSize,obstacles}=currentLevel;// 建立固定障礙物集合\nconst staticObstacles=obstacles;// 根據方向排序方塊\nconst sortedPositions=sortPositionsByDirection(blockPositions,direction);// 追蹤已停下的方塊位置\nconst stoppedPositions=new Set();const newPositions=[];const allPathCells=new Set();// 收集所有經過的格子\n// 按順序處理每個方塊\nfor(const originalPos of sortedPositions){const movement=calculateBlockMovement(originalPos,direction,gridSize,staticObstacles,stoppedPositions);// 記錄最終位置\nnewPositions.push(movement.finalPosition);stoppedPositions.add(positionToKey(movement.finalPosition));// 記錄所有經過的格子\nmovement.pathCells.forEach(cell=>{allPathCells.add(positionToKey(cell));});}// 更新覆蓋的格子 - 包含所有經過的路徑\nconst newCoveredCells=new Set(coveredCells);allPathCells.forEach(cellKey=>{newCoveredCells.add(cellKey);});// 檢查是否勝利\nconst totalCells=gridSize[0]*gridSize[1];const obstacleCount=obstacles.length;const targetCells=totalCells-obstacleCount;const isGameWon=newCoveredCells.size>=targetCells;// 檢查是否失敗\nconst isGameLost=!isGameWon&&currentTurn>=currentLevel.turnLimit;// 更新移動歷史\nconst newMoveHistory=[...gameState.moveHistory,newPositions];return _objectSpread(_objectSpread({},gameState),{},{blockPositions:newPositions,coveredCells:newCoveredCells,currentTurn:currentTurn+1,isGameWon,isGameLost,moveHistory:newMoveHistory});}// 計算覆蓋率\nexport function calculateCoverage(gameState){const{currentLevel,coveredCells}=gameState;const{gridSize,obstacles}=currentLevel;const totalCells=gridSize[0]*gridSize[1];const obstacleCount=obstacles.length;const targetCells=totalCells-obstacleCount;return Math.round(coveredCells.size/targetCells*100);}// 計算星級評分\nexport function calculateStarRating(gameState){const{currentLevel,currentTurn}=gameState;const{minSteps}=currentLevel;const movesUsed=currentTurn-1;// 因為 currentTurn 是下一回合的數字\nif(movesUsed<=minSteps+1){return{stars:3,description:'完美！'};}else if(movesUsed<=minSteps+5){return{stars:2,description:'很好！'};}else{return{stars:1,description:'完成！'};}}// 初始化遊戲狀態\nexport function initializeGameState(level){const initialCoveredCells=new Set();// 初始方塊位置視為已覆蓋\nlevel.blocks.forEach(block=>{initialCoveredCells.add(positionToKey(block));});return{currentLevel:level,blockPositions:[...level.blocks],coveredCells:initialCoveredCells,currentTurn:1,isGameWon:false,isGameLost:false,moveHistory:[level.blocks]};}// 撤銷移動\nexport function undoMove(gameState){if(gameState.moveHistory.length<=1){return gameState;// 無法撤銷\n}const newMoveHistory=gameState.moveHistory.slice(0,-1);const previousPositions=newMoveHistory[newMoveHistory.length-1];// 重新計算覆蓋的格子\nconst newCoveredCells=new Set();previousPositions.forEach(pos=>{newCoveredCells.add(positionToKey(pos));});return _objectSpread(_objectSpread({},gameState),{},{blockPositions:previousPositions,coveredCells:newCoveredCells,currentTurn:gameState.currentTurn-1,isGameWon:false,isGameLost:false,moveHistory:newMoveHistory});}","map":{"version":3,"names":["DIRECTION_VECTORS","up","row","col","down","left","right","positionToKey","pos","concat","keyToPosition","key","split","map","Number","isPositionValid","gridSize","isObstacle","obstacles","some","obs","sortPositionsByDirection","positions","direction","sorted","sort","a","b","calculateBlockMovement","startPos","stoppedPositions","vector","currentPos","_objectSpread","pathCells","nextPos","has","push","finalPosition","executeMove","gameState","currentLevel","blockPositions","coveredCells","currentTurn","staticObstacles","sortedPositions","Set","newPositions","allPathCells","originalPos","movement","add","forEach","cell","newCoveredCells","cellKey","totalCells","obstacleCount","length","targetCells","isGameWon","size","isGameLost","turnLimit","newMoveHistory","moveHistory","calculateCoverage","Math","round","calculateStarRating","minSteps","movesUsed","stars","description","initializeGameState","level","initialCoveredCells","blocks","block","undoMove","slice","previousPositions"],"sources":["/Users/arthurlin/Desktop/網服/wp1141/hw2/src/utils/GameLogic.ts"],"sourcesContent":["import { Position, Direction, GameState, Level } from '../types/GameTypes';\n\n// 方向向量\nconst DIRECTION_VECTORS: Record<Direction, Position> = {\n  up: { row: -1, col: 0 },\n  down: { row: 1, col: 0 },\n  left: { row: 0, col: -1 },\n  right: { row: 0, col: 1 }\n};\n\n// 將位置轉換為字串 key\nexport function positionToKey(pos: Position): string {\n  return `${pos.row},${pos.col}`;\n}\n\n// 將字串 key 轉換為位置\nexport function keyToPosition(key: string): Position {\n  const [row, col] = key.split(',').map(Number);\n  return { row, col };\n}\n\n// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos: Position, gridSize: [number, number]): boolean {\n  return pos.row >= 0 && pos.row < gridSize[0] && pos.col >= 0 && pos.col < gridSize[1];\n}\n\n// 檢查位置是否為障礙物\nexport function isObstacle(pos: Position, obstacles: Position[]): boolean {\n  return obstacles.some(obs => obs.row === pos.row && obs.col === pos.col);\n}\n\n// 根據方向排序方塊位置（用於確定移動順序）\nexport function sortPositionsByDirection(positions: Position[], direction: Direction): Position[] {\n  const sorted = [...positions];\n  \n  switch (direction) {\n    case 'left':\n      // 從左到右（欄位座標由小到大）\n      return sorted.sort((a, b) => a.col - b.col);\n    case 'right':\n      // 從右到左（欄位座標由大到小）\n      return sorted.sort((a, b) => b.col - a.col);\n    case 'up':\n      // 從上到下（行座標由小到大）\n      return sorted.sort((a, b) => a.row - b.row);\n    case 'down':\n      // 從下到上（行座標由大到小）\n      return sorted.sort((a, b) => b.row - a.row);\n    default:\n      return sorted;\n  }\n}\n\n// 計算方塊在指定方向能移動到的位置，並返回經過的所有格子\nexport function calculateBlockMovement(\n  startPos: Position,\n  direction: Direction,\n  gridSize: [number, number],\n  obstacles: Position[],\n  stoppedPositions: Set<string>\n): { finalPosition: Position; pathCells: Position[] } {\n  const vector = DIRECTION_VECTORS[direction];\n  let currentPos = { ...startPos };\n  const pathCells: Position[] = [{ ...startPos }]; // 包含起始位置\n  \n  while (true) {\n    const nextPos: Position = {\n      row: currentPos.row + vector.row,\n      col: currentPos.col + vector.col\n    };\n    \n    // 檢查是否超出地圖範圍\n    if (!isPositionValid(nextPos, gridSize)) {\n      break;\n    }\n    \n    // 檢查是否撞到固定障礙物\n    if (isObstacle(nextPos, obstacles)) {\n      break;\n    }\n    \n    // 檢查是否撞到已停下的方塊\n    if (stoppedPositions.has(positionToKey(nextPos))) {\n      break;\n    }\n    \n    currentPos = nextPos;\n    pathCells.push({ ...currentPos });\n  }\n  \n  return {\n    finalPosition: currentPos,\n    pathCells\n  };\n}\n\n// 執行一次移動\nexport function executeMove(\n  gameState: GameState,\n  direction: Direction\n): GameState {\n  const { currentLevel, blockPositions, coveredCells, currentTurn } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  // 建立固定障礙物集合\n  const staticObstacles = obstacles;\n  \n  // 根據方向排序方塊\n  const sortedPositions = sortPositionsByDirection(blockPositions, direction);\n  \n  // 追蹤已停下的方塊位置\n  const stoppedPositions = new Set<string>();\n  const newPositions: Position[] = [];\n  const allPathCells = new Set<string>(); // 收集所有經過的格子\n  \n  // 按順序處理每個方塊\n  for (const originalPos of sortedPositions) {\n    const movement = calculateBlockMovement(\n      originalPos,\n      direction,\n      gridSize,\n      staticObstacles,\n      stoppedPositions\n    );\n    \n    // 記錄最終位置\n    newPositions.push(movement.finalPosition);\n    stoppedPositions.add(positionToKey(movement.finalPosition));\n    \n    // 記錄所有經過的格子\n    movement.pathCells.forEach(cell => {\n      allPathCells.add(positionToKey(cell));\n    });\n  }\n  \n  // 更新覆蓋的格子 - 包含所有經過的路徑\n  const newCoveredCells = new Set(coveredCells);\n  allPathCells.forEach(cellKey => {\n    newCoveredCells.add(cellKey);\n  });\n  \n  // 檢查是否勝利\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  const isGameWon = newCoveredCells.size >= targetCells;\n  \n  // 檢查是否失敗\n  const isGameLost = !isGameWon && currentTurn >= currentLevel.turnLimit;\n  \n  // 更新移動歷史\n  const newMoveHistory = [...gameState.moveHistory, newPositions];\n  \n  return {\n    ...gameState,\n    blockPositions: newPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: currentTurn + 1,\n    isGameWon,\n    isGameLost,\n    moveHistory: newMoveHistory\n  };\n}\n\n// 計算覆蓋率\nexport function calculateCoverage(gameState: GameState): number {\n  const { currentLevel, coveredCells } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  \n  return Math.round((coveredCells.size / targetCells) * 100);\n}\n\n// 計算星級評分\nexport function calculateStarRating(gameState: GameState): { stars: 1 | 2 | 3; description: string } {\n  const { currentLevel, currentTurn } = gameState;\n  const { minSteps } = currentLevel;\n  \n  const movesUsed = currentTurn - 1; // 因為 currentTurn 是下一回合的數字\n  \n  if (movesUsed <= minSteps + 1) {\n    return { stars: 3, description: '完美！' };\n  } else if (movesUsed <= minSteps + 5) {\n    return { stars: 2, description: '很好！' };\n  } else {\n    return { stars: 1, description: '完成！' };\n  }\n}\n\n// 初始化遊戲狀態\nexport function initializeGameState(level: Level): GameState {\n  const initialCoveredCells = new Set<string>();\n  \n  // 初始方塊位置視為已覆蓋\n  level.blocks.forEach(block => {\n    initialCoveredCells.add(positionToKey(block));\n  });\n  \n  return {\n    currentLevel: level,\n    blockPositions: [...level.blocks],\n    coveredCells: initialCoveredCells,\n    currentTurn: 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: [level.blocks]\n  };\n}\n\n// 撤銷移動\nexport function undoMove(gameState: GameState): GameState {\n  if (gameState.moveHistory.length <= 1) {\n    return gameState; // 無法撤銷\n  }\n  \n  const newMoveHistory = gameState.moveHistory.slice(0, -1);\n  const previousPositions = newMoveHistory[newMoveHistory.length - 1];\n  \n  // 重新計算覆蓋的格子\n  const newCoveredCells = new Set<string>();\n  previousPositions.forEach(pos => {\n    newCoveredCells.add(positionToKey(pos));\n  });\n  \n  return {\n    ...gameState,\n    blockPositions: previousPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: gameState.currentTurn - 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: newMoveHistory\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _objectSpread from\"/Users/arthurlin/Desktop/\\u7DB2\\u670D/wp1141/hw2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// 方向向量\nconst DIRECTION_VECTORS={up:{row:-1,col:0},down:{row:1,col:0},left:{row:0,col:-1},right:{row:0,col:1}};// 將位置轉換為字串 key\nexport function positionToKey(pos){return\"\".concat(pos.row,\",\").concat(pos.col);}// 將字串 key 轉換為位置\nexport function keyToPosition(key){const[row,col]=key.split(',').map(Number);return{row,col};}// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos,gridSize){return pos.row>=0&&pos.row<gridSize[0]&&pos.col>=0&&pos.col<gridSize[1];}// 檢查位置是否為障礙物\nexport function isObstacle(pos,obstacles){return obstacles.some(obs=>obs.row===pos.row&&obs.col===pos.col);}// 根據方向排序方塊（用於確定移動順序）\nexport function sortBlocksByDirection(blocks,direction){const sorted=[...blocks];switch(direction){case'left':// 從左到右（欄位座標由小到大）\nreturn sorted.sort((a,b)=>a.position.col-b.position.col);case'right':// 從右到左（欄位座標由大到小）\nreturn sorted.sort((a,b)=>b.position.col-a.position.col);case'up':// 從上到下（行座標由小到大）\nreturn sorted.sort((a,b)=>a.position.row-b.position.row);case'down':// 從下到上（行座標由大到小）\nreturn sorted.sort((a,b)=>b.position.row-a.position.row);default:return sorted;}}// 計算方塊在指定方向能移動到的位置，並返回經過的所有格子\nexport function calculateBlockMovement(startPos,direction,gridSize,obstacles,stoppedPositions){const vector=DIRECTION_VECTORS[direction];let currentPos=_objectSpread({},startPos);const pathCells=[_objectSpread({},startPos)];// 包含起始位置\nwhile(true){const nextPos={row:currentPos.row+vector.row,col:currentPos.col+vector.col};// 檢查是否超出地圖範圍\nif(!isPositionValid(nextPos,gridSize)){break;}// 檢查是否撞到固定障礙物\nif(isObstacle(nextPos,obstacles)){break;}// 檢查是否撞到已停下的方塊\nif(stoppedPositions.has(positionToKey(nextPos))){break;}currentPos=nextPos;pathCells.push(_objectSpread({},currentPos));}return{finalPosition:currentPos,pathCells};}// 執行一次移動\nexport function executeMove(gameState,direction){const{currentLevel,blocks,coveredCells,currentTurn}=gameState;const{gridSize,obstacles}=currentLevel;// 建立固定障礙物集合\nconst staticObstacles=obstacles;// 根據方向排序方塊\nconst sortedBlocks=sortBlocksByDirection(blocks,direction);// 追蹤已停下的方塊位置\nconst stoppedPositions=new Set();const newBlocks=[];const allPathCells=new Set();// 收集所有經過的格子\n// 按順序處理每個方塊\nfor(const block of sortedBlocks){const movement=calculateBlockMovement(block.position,direction,gridSize,staticObstacles,stoppedPositions);// 記錄最終位置，保持原有的 ID\nnewBlocks.push({id:block.id,position:movement.finalPosition});stoppedPositions.add(positionToKey(movement.finalPosition));// 記錄所有經過的格子\nmovement.pathCells.forEach(cell=>{allPathCells.add(positionToKey(cell));});}// 更新覆蓋的格子 - 包含所有經過的路徑\nconst newCoveredCells=new Set(coveredCells);allPathCells.forEach(cellKey=>{newCoveredCells.add(cellKey);});// 檢查是否勝利\nconst totalCells=gridSize[0]*gridSize[1];const obstacleCount=obstacles.length;const targetCells=totalCells-obstacleCount;const isGameWon=newCoveredCells.size>=targetCells;// 檢查是否失敗\nconst isGameLost=!isGameWon&&currentTurn>=currentLevel.turnLimit;// 更新移動歷史和覆蓋歷史\nconst newMoveHistory=[...gameState.moveHistory,newBlocks];const newCoverageHistory=[...gameState.coverageHistory,new Set(newCoveredCells)];return _objectSpread(_objectSpread({},gameState),{},{blocks:newBlocks,coveredCells:newCoveredCells,currentTurn:currentTurn+1,isGameWon,isGameLost,moveHistory:newMoveHistory,coverageHistory:newCoverageHistory});}// 計算覆蓋率\nexport function calculateCoverage(gameState){const{currentLevel,coveredCells}=gameState;const{gridSize,obstacles}=currentLevel;const totalCells=gridSize[0]*gridSize[1];const obstacleCount=obstacles.length;const targetCells=totalCells-obstacleCount;return Math.round(coveredCells.size/targetCells*100);}// 計算星級評分\nexport function calculateStarRating(gameState){const{currentLevel,currentTurn}=gameState;const{minSteps}=currentLevel;const movesUsed=currentTurn-1;// 因為 currentTurn 是下一回合的數字\nif(movesUsed<=minSteps+1){return{stars:3,description:'完美！'};}else if(movesUsed<=minSteps+5){return{stars:2,description:'很好！'};}else{return{stars:1,description:'完成！'};}}// 初始化遊戲狀態\nexport function initializeGameState(level){const initialCoveredCells=new Set();// 創建帶有固定 ID 的方塊\nconst initialBlocks=level.blocks.map((position,index)=>({id:index+1,position}));// 初始方塊位置視為已覆蓋\ninitialBlocks.forEach(block=>{initialCoveredCells.add(positionToKey(block.position));});return{currentLevel:level,blocks:initialBlocks,coveredCells:initialCoveredCells,currentTurn:1,isGameWon:false,isGameLost:false,moveHistory:[initialBlocks],coverageHistory:[new Set(initialCoveredCells)]};}// 撤銷移動\nexport function undoMove(gameState){if(gameState.moveHistory.length<=1||gameState.coverageHistory.length<=1){return gameState;// 無法撤銷\n}const newMoveHistory=gameState.moveHistory.slice(0,-1);const newCoverageHistory=gameState.coverageHistory.slice(0,-1);const previousBlocks=newMoveHistory[newMoveHistory.length-1];const previousCoverage=newCoverageHistory[newCoverageHistory.length-1];return _objectSpread(_objectSpread({},gameState),{},{blocks:previousBlocks,coveredCells:new Set(previousCoverage),// 恢復之前的覆蓋狀態\ncurrentTurn:gameState.currentTurn-1,isGameWon:false,isGameLost:false,moveHistory:newMoveHistory,coverageHistory:newCoverageHistory});}","map":{"version":3,"names":["DIRECTION_VECTORS","up","row","col","down","left","right","positionToKey","pos","concat","keyToPosition","key","split","map","Number","isPositionValid","gridSize","isObstacle","obstacles","some","obs","sortBlocksByDirection","blocks","direction","sorted","sort","a","b","position","calculateBlockMovement","startPos","stoppedPositions","vector","currentPos","_objectSpread","pathCells","nextPos","has","push","finalPosition","executeMove","gameState","currentLevel","coveredCells","currentTurn","staticObstacles","sortedBlocks","Set","newBlocks","allPathCells","block","movement","id","add","forEach","cell","newCoveredCells","cellKey","totalCells","obstacleCount","length","targetCells","isGameWon","size","isGameLost","turnLimit","newMoveHistory","moveHistory","newCoverageHistory","coverageHistory","calculateCoverage","Math","round","calculateStarRating","minSteps","movesUsed","stars","description","initializeGameState","level","initialCoveredCells","initialBlocks","index","undoMove","slice","previousBlocks","previousCoverage"],"sources":["/Users/arthurlin/Desktop/網服/wp1141/hw2/src/utils/GameLogic.ts"],"sourcesContent":["import { Position, Direction, GameState, Level, Block } from '../types/GameTypes';\n\n// 方向向量\nconst DIRECTION_VECTORS: Record<Direction, Position> = {\n  up: { row: -1, col: 0 },\n  down: { row: 1, col: 0 },\n  left: { row: 0, col: -1 },\n  right: { row: 0, col: 1 }\n};\n\n// 將位置轉換為字串 key\nexport function positionToKey(pos: Position): string {\n  return `${pos.row},${pos.col}`;\n}\n\n// 將字串 key 轉換為位置\nexport function keyToPosition(key: string): Position {\n  const [row, col] = key.split(',').map(Number);\n  return { row, col };\n}\n\n// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos: Position, gridSize: [number, number]): boolean {\n  return pos.row >= 0 && pos.row < gridSize[0] && pos.col >= 0 && pos.col < gridSize[1];\n}\n\n// 檢查位置是否為障礙物\nexport function isObstacle(pos: Position, obstacles: Position[]): boolean {\n  return obstacles.some(obs => obs.row === pos.row && obs.col === pos.col);\n}\n\n// 根據方向排序方塊（用於確定移動順序）\nexport function sortBlocksByDirection(blocks: Block[], direction: Direction): Block[] {\n  const sorted = [...blocks];\n  \n  switch (direction) {\n    case 'left':\n      // 從左到右（欄位座標由小到大）\n      return sorted.sort((a, b) => a.position.col - b.position.col);\n    case 'right':\n      // 從右到左（欄位座標由大到小）\n      return sorted.sort((a, b) => b.position.col - a.position.col);\n    case 'up':\n      // 從上到下（行座標由小到大）\n      return sorted.sort((a, b) => a.position.row - b.position.row);\n    case 'down':\n      // 從下到上（行座標由大到小）\n      return sorted.sort((a, b) => b.position.row - a.position.row);\n    default:\n      return sorted;\n  }\n}\n\n// 計算方塊在指定方向能移動到的位置，並返回經過的所有格子\nexport function calculateBlockMovement(\n  startPos: Position,\n  direction: Direction,\n  gridSize: [number, number],\n  obstacles: Position[],\n  stoppedPositions: Set<string>\n): { finalPosition: Position; pathCells: Position[] } {\n  const vector = DIRECTION_VECTORS[direction];\n  let currentPos = { ...startPos };\n  const pathCells: Position[] = [{ ...startPos }]; // 包含起始位置\n  \n  while (true) {\n    const nextPos: Position = {\n      row: currentPos.row + vector.row,\n      col: currentPos.col + vector.col\n    };\n    \n    // 檢查是否超出地圖範圍\n    if (!isPositionValid(nextPos, gridSize)) {\n      break;\n    }\n    \n    // 檢查是否撞到固定障礙物\n    if (isObstacle(nextPos, obstacles)) {\n      break;\n    }\n    \n    // 檢查是否撞到已停下的方塊\n    if (stoppedPositions.has(positionToKey(nextPos))) {\n      break;\n    }\n    \n    currentPos = nextPos;\n    pathCells.push({ ...currentPos });\n  }\n  \n  return {\n    finalPosition: currentPos,\n    pathCells\n  };\n}\n\n// 執行一次移動\nexport function executeMove(\n  gameState: GameState,\n  direction: Direction\n): GameState {\n  const { currentLevel, blocks, coveredCells, currentTurn } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  // 建立固定障礙物集合\n  const staticObstacles = obstacles;\n  \n  // 根據方向排序方塊\n  const sortedBlocks = sortBlocksByDirection(blocks, direction);\n  \n  // 追蹤已停下的方塊位置\n  const stoppedPositions = new Set<string>();\n  const newBlocks: Block[] = [];\n  const allPathCells = new Set<string>(); // 收集所有經過的格子\n  \n  // 按順序處理每個方塊\n  for (const block of sortedBlocks) {\n    const movement = calculateBlockMovement(\n      block.position,\n      direction,\n      gridSize,\n      staticObstacles,\n      stoppedPositions\n    );\n    \n    // 記錄最終位置，保持原有的 ID\n    newBlocks.push({\n      id: block.id,\n      position: movement.finalPosition\n    });\n    stoppedPositions.add(positionToKey(movement.finalPosition));\n    \n    // 記錄所有經過的格子\n    movement.pathCells.forEach(cell => {\n      allPathCells.add(positionToKey(cell));\n    });\n  }\n  \n  // 更新覆蓋的格子 - 包含所有經過的路徑\n  const newCoveredCells = new Set(coveredCells);\n  allPathCells.forEach(cellKey => {\n    newCoveredCells.add(cellKey);\n  });\n  \n  // 檢查是否勝利\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  const isGameWon = newCoveredCells.size >= targetCells;\n  \n  // 檢查是否失敗\n  const isGameLost = !isGameWon && currentTurn >= currentLevel.turnLimit;\n  \n  // 更新移動歷史和覆蓋歷史\n  const newMoveHistory = [...gameState.moveHistory, newBlocks];\n  const newCoverageHistory = [...gameState.coverageHistory, new Set(newCoveredCells)];\n  \n  return {\n    ...gameState,\n    blocks: newBlocks,\n    coveredCells: newCoveredCells,\n    currentTurn: currentTurn + 1,\n    isGameWon,\n    isGameLost,\n    moveHistory: newMoveHistory,\n    coverageHistory: newCoverageHistory\n  };\n}\n\n// 計算覆蓋率\nexport function calculateCoverage(gameState: GameState): number {\n  const { currentLevel, coveredCells } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  \n  return Math.round((coveredCells.size / targetCells) * 100);\n}\n\n// 計算星級評分\nexport function calculateStarRating(gameState: GameState): { stars: 1 | 2 | 3; description: string } {\n  const { currentLevel, currentTurn } = gameState;\n  const { minSteps } = currentLevel;\n  \n  const movesUsed = currentTurn - 1; // 因為 currentTurn 是下一回合的數字\n  \n  if (movesUsed <= minSteps + 1) {\n    return { stars: 3, description: '完美！' };\n  } else if (movesUsed <= minSteps + 5) {\n    return { stars: 2, description: '很好！' };\n  } else {\n    return { stars: 1, description: '完成！' };\n  }\n}\n\n// 初始化遊戲狀態\nexport function initializeGameState(level: Level): GameState {\n  const initialCoveredCells = new Set<string>();\n  \n  // 創建帶有固定 ID 的方塊\n  const initialBlocks: Block[] = level.blocks.map((position, index) => ({\n    id: index + 1,\n    position\n  }));\n  \n  // 初始方塊位置視為已覆蓋\n  initialBlocks.forEach(block => {\n    initialCoveredCells.add(positionToKey(block.position));\n  });\n  \n  return {\n    currentLevel: level,\n    blocks: initialBlocks,\n    coveredCells: initialCoveredCells,\n    currentTurn: 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: [initialBlocks],\n    coverageHistory: [new Set(initialCoveredCells)]\n  };\n}\n\n// 撤銷移動\nexport function undoMove(gameState: GameState): GameState {\n  if (gameState.moveHistory.length <= 1 || gameState.coverageHistory.length <= 1) {\n    return gameState; // 無法撤銷\n  }\n  \n  const newMoveHistory = gameState.moveHistory.slice(0, -1);\n  const newCoverageHistory = gameState.coverageHistory.slice(0, -1);\n  const previousBlocks = newMoveHistory[newMoveHistory.length - 1];\n  const previousCoverage = newCoverageHistory[newCoverageHistory.length - 1];\n  \n  return {\n    ...gameState,\n    blocks: previousBlocks,\n    coveredCells: new Set(previousCoverage), // 恢復之前的覆蓋狀態\n    currentTurn: gameState.currentTurn - 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: newMoveHistory,\n    coverageHistory: newCoverageHistory\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"// 方向向量\nconst DIRECTION_VECTORS = {\n  up: {\n    row: -1,\n    col: 0\n  },\n  down: {\n    row: 1,\n    col: 0\n  },\n  left: {\n    row: 0,\n    col: -1\n  },\n  right: {\n    row: 0,\n    col: 1\n  }\n};\n\n// 將位置轉換為字串 key\nexport function positionToKey(pos) {\n  return `${pos.row},${pos.col}`;\n}\n\n// 將字串 key 轉換為位置\nexport function keyToPosition(key) {\n  const [row, col] = key.split(',').map(Number);\n  return {\n    row,\n    col\n  };\n}\n\n// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos, gridSize) {\n  return pos.row >= 0 && pos.row < gridSize[0] && pos.col >= 0 && pos.col < gridSize[1];\n}\n\n// 檢查位置是否為障礙物\nexport function isObstacle(pos, obstacles) {\n  return obstacles.some(obs => obs.row === pos.row && obs.col === pos.col);\n}\n\n// 根據方向排序方塊（用於確定移動順序）\nexport function sortBlocksByDirection(blocks, direction) {\n  const sorted = [...blocks];\n  switch (direction) {\n    case 'left':\n      // 從左到右（欄位座標由小到大）\n      return sorted.sort((a, b) => a.position.col - b.position.col);\n    case 'right':\n      // 從右到左（欄位座標由大到小）\n      return sorted.sort((a, b) => b.position.col - a.position.col);\n    case 'up':\n      // 從上到下（行座標由小到大）\n      return sorted.sort((a, b) => a.position.row - b.position.row);\n    case 'down':\n      // 從下到上（行座標由大到小）\n      return sorted.sort((a, b) => b.position.row - a.position.row);\n    default:\n      return sorted;\n  }\n}\n\n// 計算方塊在指定方向能移動到的位置，並返回經過的所有格子\nexport function calculateBlockMovement(startPos, direction, gridSize, obstacles, stoppedPositions) {\n  const vector = DIRECTION_VECTORS[direction];\n  let currentPos = {\n    ...startPos\n  };\n  const pathCells = [{\n    ...startPos\n  }]; // 包含起始位置\n\n  while (true) {\n    const nextPos = {\n      row: currentPos.row + vector.row,\n      col: currentPos.col + vector.col\n    };\n\n    // 檢查是否超出地圖範圍\n    if (!isPositionValid(nextPos, gridSize)) {\n      break;\n    }\n\n    // 檢查是否撞到固定障礙物\n    if (isObstacle(nextPos, obstacles)) {\n      break;\n    }\n\n    // 檢查是否撞到已停下的方塊\n    if (stoppedPositions.has(positionToKey(nextPos))) {\n      break;\n    }\n    currentPos = nextPos;\n    pathCells.push({\n      ...currentPos\n    });\n  }\n  return {\n    finalPosition: currentPos,\n    pathCells\n  };\n}\n\n// 執行一次移動\nexport function executeMove(gameState, direction) {\n  const {\n    currentLevel,\n    blocks,\n    coveredCells,\n    currentTurn\n  } = gameState;\n  const {\n    gridSize,\n    obstacles\n  } = currentLevel;\n\n  // 建立固定障礙物集合\n  const staticObstacles = obstacles;\n\n  // 根據方向排序方塊\n  const sortedBlocks = sortBlocksByDirection(blocks, direction);\n\n  // 追蹤已停下的方塊位置\n  const stoppedPositions = new Set();\n  const newBlocks = [];\n  const allPathCells = new Set(); // 收集所有經過的格子\n\n  // 按順序處理每個方塊\n  for (const block of sortedBlocks) {\n    const movement = calculateBlockMovement(block.position, direction, gridSize, staticObstacles, stoppedPositions);\n\n    // 記錄最終位置，保持原有的 ID\n    newBlocks.push({\n      id: block.id,\n      position: movement.finalPosition\n    });\n    stoppedPositions.add(positionToKey(movement.finalPosition));\n\n    // 記錄所有經過的格子\n    movement.pathCells.forEach(cell => {\n      allPathCells.add(positionToKey(cell));\n    });\n  }\n\n  // 更新覆蓋的格子 - 包含所有經過的路徑\n  const newCoveredCells = new Set(coveredCells);\n  allPathCells.forEach(cellKey => {\n    newCoveredCells.add(cellKey);\n  });\n\n  // 檢查是否勝利\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  const isGameWon = newCoveredCells.size >= targetCells;\n\n  // 檢查是否失敗\n  const isGameLost = !isGameWon && currentTurn >= currentLevel.turnLimit;\n\n  // 更新移動歷史\n  const newMoveHistory = [...gameState.moveHistory, newBlocks];\n  return {\n    ...gameState,\n    blocks: newBlocks,\n    coveredCells: newCoveredCells,\n    currentTurn: currentTurn + 1,\n    isGameWon,\n    isGameLost,\n    moveHistory: newMoveHistory\n  };\n}\n\n// 計算覆蓋率\nexport function calculateCoverage(gameState) {\n  const {\n    currentLevel,\n    coveredCells\n  } = gameState;\n  const {\n    gridSize,\n    obstacles\n  } = currentLevel;\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  return Math.round(coveredCells.size / targetCells * 100);\n}\n\n// 計算星級評分\nexport function calculateStarRating(gameState) {\n  const {\n    currentLevel,\n    currentTurn\n  } = gameState;\n  const {\n    minSteps\n  } = currentLevel;\n  const movesUsed = currentTurn - 1; // 因為 currentTurn 是下一回合的數字\n\n  if (movesUsed <= minSteps + 1) {\n    return {\n      stars: 3,\n      description: '完美！'\n    };\n  } else if (movesUsed <= minSteps + 5) {\n    return {\n      stars: 2,\n      description: '很好！'\n    };\n  } else {\n    return {\n      stars: 1,\n      description: '完成！'\n    };\n  }\n}\n\n// 初始化遊戲狀態\nexport function initializeGameState(level) {\n  const initialCoveredCells = new Set();\n\n  // 創建帶有固定 ID 的方塊\n  const initialBlocks = level.blocks.map((position, index) => ({\n    id: index + 1,\n    position\n  }));\n\n  // 初始方塊位置視為已覆蓋\n  initialBlocks.forEach(block => {\n    initialCoveredCells.add(positionToKey(block.position));\n  });\n  return {\n    currentLevel: level,\n    blocks: initialBlocks,\n    coveredCells: initialCoveredCells,\n    currentTurn: 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: [initialBlocks],\n    coverageHistory: [new Set(initialCoveredCells)]\n  };\n}\n\n// 撤銷移動\nexport function undoMove(gameState) {\n  if (gameState.moveHistory.length <= 1) {\n    return gameState; // 無法撤銷\n  }\n  const newMoveHistory = gameState.moveHistory.slice(0, -1);\n  const previousBlocks = newMoveHistory[newMoveHistory.length - 1];\n\n  // 重新計算覆蓋的格子\n  const newCoveredCells = new Set();\n  previousBlocks.forEach(block => {\n    newCoveredCells.add(positionToKey(block.position));\n  });\n  return {\n    ...gameState,\n    blocks: previousBlocks,\n    coveredCells: newCoveredCells,\n    currentTurn: gameState.currentTurn - 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: newMoveHistory\n  };\n}","map":{"version":3,"names":["DIRECTION_VECTORS","up","row","col","down","left","right","positionToKey","pos","keyToPosition","key","split","map","Number","isPositionValid","gridSize","isObstacle","obstacles","some","obs","sortBlocksByDirection","blocks","direction","sorted","sort","a","b","position","calculateBlockMovement","startPos","stoppedPositions","vector","currentPos","pathCells","nextPos","has","push","finalPosition","executeMove","gameState","currentLevel","coveredCells","currentTurn","staticObstacles","sortedBlocks","Set","newBlocks","allPathCells","block","movement","id","add","forEach","cell","newCoveredCells","cellKey","totalCells","obstacleCount","length","targetCells","isGameWon","size","isGameLost","turnLimit","newMoveHistory","moveHistory","calculateCoverage","Math","round","calculateStarRating","minSteps","movesUsed","stars","description","initializeGameState","level","initialCoveredCells","initialBlocks","index","coverageHistory","undoMove","slice","previousBlocks"],"sources":["/Users/arthurlin/Desktop/網服/wp1141/hw2/src/utils/GameLogic.ts"],"sourcesContent":["import { Position, Direction, GameState, Level, Block } from '../types/GameTypes';\n\n// 方向向量\nconst DIRECTION_VECTORS: Record<Direction, Position> = {\n  up: { row: -1, col: 0 },\n  down: { row: 1, col: 0 },\n  left: { row: 0, col: -1 },\n  right: { row: 0, col: 1 }\n};\n\n// 將位置轉換為字串 key\nexport function positionToKey(pos: Position): string {\n  return `${pos.row},${pos.col}`;\n}\n\n// 將字串 key 轉換為位置\nexport function keyToPosition(key: string): Position {\n  const [row, col] = key.split(',').map(Number);\n  return { row, col };\n}\n\n// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos: Position, gridSize: [number, number]): boolean {\n  return pos.row >= 0 && pos.row < gridSize[0] && pos.col >= 0 && pos.col < gridSize[1];\n}\n\n// 檢查位置是否為障礙物\nexport function isObstacle(pos: Position, obstacles: Position[]): boolean {\n  return obstacles.some(obs => obs.row === pos.row && obs.col === pos.col);\n}\n\n// 根據方向排序方塊（用於確定移動順序）\nexport function sortBlocksByDirection(blocks: Block[], direction: Direction): Block[] {\n  const sorted = [...blocks];\n  \n  switch (direction) {\n    case 'left':\n      // 從左到右（欄位座標由小到大）\n      return sorted.sort((a, b) => a.position.col - b.position.col);\n    case 'right':\n      // 從右到左（欄位座標由大到小）\n      return sorted.sort((a, b) => b.position.col - a.position.col);\n    case 'up':\n      // 從上到下（行座標由小到大）\n      return sorted.sort((a, b) => a.position.row - b.position.row);\n    case 'down':\n      // 從下到上（行座標由大到小）\n      return sorted.sort((a, b) => b.position.row - a.position.row);\n    default:\n      return sorted;\n  }\n}\n\n// 計算方塊在指定方向能移動到的位置，並返回經過的所有格子\nexport function calculateBlockMovement(\n  startPos: Position,\n  direction: Direction,\n  gridSize: [number, number],\n  obstacles: Position[],\n  stoppedPositions: Set<string>\n): { finalPosition: Position; pathCells: Position[] } {\n  const vector = DIRECTION_VECTORS[direction];\n  let currentPos = { ...startPos };\n  const pathCells: Position[] = [{ ...startPos }]; // 包含起始位置\n  \n  while (true) {\n    const nextPos: Position = {\n      row: currentPos.row + vector.row,\n      col: currentPos.col + vector.col\n    };\n    \n    // 檢查是否超出地圖範圍\n    if (!isPositionValid(nextPos, gridSize)) {\n      break;\n    }\n    \n    // 檢查是否撞到固定障礙物\n    if (isObstacle(nextPos, obstacles)) {\n      break;\n    }\n    \n    // 檢查是否撞到已停下的方塊\n    if (stoppedPositions.has(positionToKey(nextPos))) {\n      break;\n    }\n    \n    currentPos = nextPos;\n    pathCells.push({ ...currentPos });\n  }\n  \n  return {\n    finalPosition: currentPos,\n    pathCells\n  };\n}\n\n// 執行一次移動\nexport function executeMove(\n  gameState: GameState,\n  direction: Direction\n): GameState {\n  const { currentLevel, blocks, coveredCells, currentTurn } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  // 建立固定障礙物集合\n  const staticObstacles = obstacles;\n  \n  // 根據方向排序方塊\n  const sortedBlocks = sortBlocksByDirection(blocks, direction);\n  \n  // 追蹤已停下的方塊位置\n  const stoppedPositions = new Set<string>();\n  const newBlocks: Block[] = [];\n  const allPathCells = new Set<string>(); // 收集所有經過的格子\n  \n  // 按順序處理每個方塊\n  for (const block of sortedBlocks) {\n    const movement = calculateBlockMovement(\n      block.position,\n      direction,\n      gridSize,\n      staticObstacles,\n      stoppedPositions\n    );\n    \n    // 記錄最終位置，保持原有的 ID\n    newBlocks.push({\n      id: block.id,\n      position: movement.finalPosition\n    });\n    stoppedPositions.add(positionToKey(movement.finalPosition));\n    \n    // 記錄所有經過的格子\n    movement.pathCells.forEach(cell => {\n      allPathCells.add(positionToKey(cell));\n    });\n  }\n  \n  // 更新覆蓋的格子 - 包含所有經過的路徑\n  const newCoveredCells = new Set(coveredCells);\n  allPathCells.forEach(cellKey => {\n    newCoveredCells.add(cellKey);\n  });\n  \n  // 檢查是否勝利\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  const isGameWon = newCoveredCells.size >= targetCells;\n  \n  // 檢查是否失敗\n  const isGameLost = !isGameWon && currentTurn >= currentLevel.turnLimit;\n  \n  // 更新移動歷史\n  const newMoveHistory = [...gameState.moveHistory, newBlocks];\n  \n  return {\n    ...gameState,\n    blocks: newBlocks,\n    coveredCells: newCoveredCells,\n    currentTurn: currentTurn + 1,\n    isGameWon,\n    isGameLost,\n    moveHistory: newMoveHistory\n  };\n}\n\n// 計算覆蓋率\nexport function calculateCoverage(gameState: GameState): number {\n  const { currentLevel, coveredCells } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  \n  return Math.round((coveredCells.size / targetCells) * 100);\n}\n\n// 計算星級評分\nexport function calculateStarRating(gameState: GameState): { stars: 1 | 2 | 3; description: string } {\n  const { currentLevel, currentTurn } = gameState;\n  const { minSteps } = currentLevel;\n  \n  const movesUsed = currentTurn - 1; // 因為 currentTurn 是下一回合的數字\n  \n  if (movesUsed <= minSteps + 1) {\n    return { stars: 3, description: '完美！' };\n  } else if (movesUsed <= minSteps + 5) {\n    return { stars: 2, description: '很好！' };\n  } else {\n    return { stars: 1, description: '完成！' };\n  }\n}\n\n// 初始化遊戲狀態\nexport function initializeGameState(level: Level): GameState {\n  const initialCoveredCells = new Set<string>();\n  \n  // 創建帶有固定 ID 的方塊\n  const initialBlocks: Block[] = level.blocks.map((position, index) => ({\n    id: index + 1,\n    position\n  }));\n  \n  // 初始方塊位置視為已覆蓋\n  initialBlocks.forEach(block => {\n    initialCoveredCells.add(positionToKey(block.position));\n  });\n  \n  return {\n    currentLevel: level,\n    blocks: initialBlocks,\n    coveredCells: initialCoveredCells,\n    currentTurn: 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: [initialBlocks],\n    coverageHistory: [new Set(initialCoveredCells)]\n  };\n}\n\n// 撤銷移動\nexport function undoMove(gameState: GameState): GameState {\n  if (gameState.moveHistory.length <= 1) {\n    return gameState; // 無法撤銷\n  }\n  \n  const newMoveHistory = gameState.moveHistory.slice(0, -1);\n  const previousBlocks = newMoveHistory[newMoveHistory.length - 1];\n  \n  // 重新計算覆蓋的格子\n  const newCoveredCells = new Set<string>();\n  previousBlocks.forEach(block => {\n    newCoveredCells.add(positionToKey(block.position));\n  });\n  \n  return {\n    ...gameState,\n    blocks: previousBlocks,\n    coveredCells: newCoveredCells,\n    currentTurn: gameState.currentTurn - 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: newMoveHistory\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
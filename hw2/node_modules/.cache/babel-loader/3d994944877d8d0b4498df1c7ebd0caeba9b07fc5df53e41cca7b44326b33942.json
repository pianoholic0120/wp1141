{"ast":null,"code":"import _objectSpread from\"/Users/arthurlin/Desktop/\\u7DB2\\u670D/wp1141/hw2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// 方向向量\nconst DIRECTION_VECTORS={up:{row:-1,col:0},down:{row:1,col:0},left:{row:0,col:-1},right:{row:0,col:1}};// 將位置轉換為字串 key\nexport function positionToKey(pos){return\"\".concat(pos.row,\",\").concat(pos.col);}// 將字串 key 轉換為位置\nexport function keyToPosition(key){const[row,col]=key.split(',').map(Number);return{row,col};}// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos,gridSize){return pos.row>=0&&pos.row<gridSize[0]&&pos.col>=0&&pos.col<gridSize[1];}// 檢查位置是否為障礙物\nexport function isObstacle(pos,obstacles){return obstacles.some(obs=>obs.row===pos.row&&obs.col===pos.col);}// 根據方向排序方塊位置（用於確定移動順序）\nexport function sortPositionsByDirection(positions,direction){const sorted=[...positions];switch(direction){case'left':// 從左到右（欄位座標由小到大）\nreturn sorted.sort((a,b)=>a.col-b.col);case'right':// 從右到左（欄位座標由大到小）\nreturn sorted.sort((a,b)=>b.col-a.col);case'up':// 從上到下（行座標由小到大）\nreturn sorted.sort((a,b)=>a.row-b.row);case'down':// 從下到上（行座標由大到小）\nreturn sorted.sort((a,b)=>b.row-a.row);default:return sorted;}}// 計算方塊在指定方向能移動到的位置\nexport function calculateBlockPosition(startPos,direction,gridSize,obstacles,stoppedPositions){const vector=DIRECTION_VECTORS[direction];let currentPos=_objectSpread({},startPos);while(true){const nextPos={row:currentPos.row+vector.row,col:currentPos.col+vector.col};// 檢查是否超出地圖範圍\nif(!isPositionValid(nextPos,gridSize)){break;}// 檢查是否撞到固定障礙物\nif(isObstacle(nextPos,obstacles)){break;}// 檢查是否撞到已停下的方塊\nif(stoppedPositions.has(positionToKey(nextPos))){break;}currentPos=nextPos;}return currentPos;}// 執行一次移動\nexport function executeMove(gameState,direction){const{currentLevel,blockPositions,coveredCells,currentTurn}=gameState;const{gridSize,obstacles}=currentLevel;// 建立固定障礙物集合\nconst staticObstacles=obstacles;// 根據方向排序方塊\nconst sortedPositions=sortPositionsByDirection(blockPositions,direction);// 追蹤已停下的方塊位置\nconst stoppedPositions=new Set();const newPositions=[];// 按順序處理每個方塊\nfor(const originalPos of sortedPositions){const newPos=calculateBlockPosition(originalPos,direction,gridSize,staticObstacles,stoppedPositions);newPositions.push(newPos);stoppedPositions.add(positionToKey(newPos));}// 更新覆蓋的格子\nconst newCoveredCells=new Set(coveredCells);newPositions.forEach(pos=>{newCoveredCells.add(positionToKey(pos));});// 檢查是否勝利\nconst totalCells=gridSize[0]*gridSize[1];const obstacleCount=obstacles.length;const targetCells=totalCells-obstacleCount;const isGameWon=newCoveredCells.size>=targetCells;// 檢查是否失敗\nconst isGameLost=!isGameWon&&currentTurn>=currentLevel.turnLimit;// 更新移動歷史\nconst newMoveHistory=[...gameState.moveHistory,newPositions];return _objectSpread(_objectSpread({},gameState),{},{blockPositions:newPositions,coveredCells:newCoveredCells,currentTurn:currentTurn+1,isGameWon,isGameLost,moveHistory:newMoveHistory});}// 計算覆蓋率\nexport function calculateCoverage(gameState){const{currentLevel,coveredCells}=gameState;const{gridSize,obstacles}=currentLevel;const totalCells=gridSize[0]*gridSize[1];const obstacleCount=obstacles.length;const targetCells=totalCells-obstacleCount;return Math.round(coveredCells.size/targetCells*100);}// 計算星級評分\nexport function calculateStarRating(gameState){const{currentLevel,currentTurn}=gameState;const{minSteps}=currentLevel;const movesUsed=currentTurn-1;// 因為 currentTurn 是下一回合的數字\nif(movesUsed<=minSteps+1){return{stars:3,description:'完美！'};}else if(movesUsed<=minSteps+5){return{stars:2,description:'很好！'};}else{return{stars:1,description:'完成！'};}}// 初始化遊戲狀態\nexport function initializeGameState(level){const initialCoveredCells=new Set();// 初始方塊位置視為已覆蓋\nlevel.blocks.forEach(block=>{initialCoveredCells.add(positionToKey(block));});return{currentLevel:level,blockPositions:[...level.blocks],coveredCells:initialCoveredCells,currentTurn:1,isGameWon:false,isGameLost:false,moveHistory:[level.blocks]};}// 撤銷移動\nexport function undoMove(gameState){if(gameState.moveHistory.length<=1){return gameState;// 無法撤銷\n}const newMoveHistory=gameState.moveHistory.slice(0,-1);const previousPositions=newMoveHistory[newMoveHistory.length-1];// 重新計算覆蓋的格子\nconst newCoveredCells=new Set();previousPositions.forEach(pos=>{newCoveredCells.add(positionToKey(pos));});return _objectSpread(_objectSpread({},gameState),{},{blockPositions:previousPositions,coveredCells:newCoveredCells,currentTurn:gameState.currentTurn-1,isGameWon:false,isGameLost:false,moveHistory:newMoveHistory});}","map":{"version":3,"names":["DIRECTION_VECTORS","up","row","col","down","left","right","positionToKey","pos","concat","keyToPosition","key","split","map","Number","isPositionValid","gridSize","isObstacle","obstacles","some","obs","sortPositionsByDirection","positions","direction","sorted","sort","a","b","calculateBlockPosition","startPos","stoppedPositions","vector","currentPos","_objectSpread","nextPos","has","executeMove","gameState","currentLevel","blockPositions","coveredCells","currentTurn","staticObstacles","sortedPositions","Set","newPositions","originalPos","newPos","push","add","newCoveredCells","forEach","totalCells","obstacleCount","length","targetCells","isGameWon","size","isGameLost","turnLimit","newMoveHistory","moveHistory","calculateCoverage","Math","round","calculateStarRating","minSteps","movesUsed","stars","description","initializeGameState","level","initialCoveredCells","blocks","block","undoMove","slice","previousPositions"],"sources":["/Users/arthurlin/Desktop/網服/wp1141/hw2/src/utils/GameLogic.ts"],"sourcesContent":["import { Position, Direction, GameState, Level } from '../types/GameTypes';\n\n// 方向向量\nconst DIRECTION_VECTORS: Record<Direction, Position> = {\n  up: { row: -1, col: 0 },\n  down: { row: 1, col: 0 },\n  left: { row: 0, col: -1 },\n  right: { row: 0, col: 1 }\n};\n\n// 將位置轉換為字串 key\nexport function positionToKey(pos: Position): string {\n  return `${pos.row},${pos.col}`;\n}\n\n// 將字串 key 轉換為位置\nexport function keyToPosition(key: string): Position {\n  const [row, col] = key.split(',').map(Number);\n  return { row, col };\n}\n\n// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos: Position, gridSize: [number, number]): boolean {\n  return pos.row >= 0 && pos.row < gridSize[0] && pos.col >= 0 && pos.col < gridSize[1];\n}\n\n// 檢查位置是否為障礙物\nexport function isObstacle(pos: Position, obstacles: Position[]): boolean {\n  return obstacles.some(obs => obs.row === pos.row && obs.col === pos.col);\n}\n\n// 根據方向排序方塊位置（用於確定移動順序）\nexport function sortPositionsByDirection(positions: Position[], direction: Direction): Position[] {\n  const sorted = [...positions];\n  \n  switch (direction) {\n    case 'left':\n      // 從左到右（欄位座標由小到大）\n      return sorted.sort((a, b) => a.col - b.col);\n    case 'right':\n      // 從右到左（欄位座標由大到小）\n      return sorted.sort((a, b) => b.col - a.col);\n    case 'up':\n      // 從上到下（行座標由小到大）\n      return sorted.sort((a, b) => a.row - b.row);\n    case 'down':\n      // 從下到上（行座標由大到小）\n      return sorted.sort((a, b) => b.row - a.row);\n    default:\n      return sorted;\n  }\n}\n\n// 計算方塊在指定方向能移動到的位置\nexport function calculateBlockPosition(\n  startPos: Position,\n  direction: Direction,\n  gridSize: [number, number],\n  obstacles: Position[],\n  stoppedPositions: Set<string>\n): Position {\n  const vector = DIRECTION_VECTORS[direction];\n  let currentPos = { ...startPos };\n  \n  while (true) {\n    const nextPos: Position = {\n      row: currentPos.row + vector.row,\n      col: currentPos.col + vector.col\n    };\n    \n    // 檢查是否超出地圖範圍\n    if (!isPositionValid(nextPos, gridSize)) {\n      break;\n    }\n    \n    // 檢查是否撞到固定障礙物\n    if (isObstacle(nextPos, obstacles)) {\n      break;\n    }\n    \n    // 檢查是否撞到已停下的方塊\n    if (stoppedPositions.has(positionToKey(nextPos))) {\n      break;\n    }\n    \n    currentPos = nextPos;\n  }\n  \n  return currentPos;\n}\n\n// 執行一次移動\nexport function executeMove(\n  gameState: GameState,\n  direction: Direction\n): GameState {\n  const { currentLevel, blockPositions, coveredCells, currentTurn } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  // 建立固定障礙物集合\n  const staticObstacles = obstacles;\n  \n  // 根據方向排序方塊\n  const sortedPositions = sortPositionsByDirection(blockPositions, direction);\n  \n  // 追蹤已停下的方塊位置\n  const stoppedPositions = new Set<string>();\n  const newPositions: Position[] = [];\n  \n  // 按順序處理每個方塊\n  for (const originalPos of sortedPositions) {\n    const newPos = calculateBlockPosition(\n      originalPos,\n      direction,\n      gridSize,\n      staticObstacles,\n      stoppedPositions\n    );\n    \n    newPositions.push(newPos);\n    stoppedPositions.add(positionToKey(newPos));\n  }\n  \n  // 更新覆蓋的格子\n  const newCoveredCells = new Set(coveredCells);\n  newPositions.forEach(pos => {\n    newCoveredCells.add(positionToKey(pos));\n  });\n  \n  // 檢查是否勝利\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  const isGameWon = newCoveredCells.size >= targetCells;\n  \n  // 檢查是否失敗\n  const isGameLost = !isGameWon && currentTurn >= currentLevel.turnLimit;\n  \n  // 更新移動歷史\n  const newMoveHistory = [...gameState.moveHistory, newPositions];\n  \n  return {\n    ...gameState,\n    blockPositions: newPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: currentTurn + 1,\n    isGameWon,\n    isGameLost,\n    moveHistory: newMoveHistory\n  };\n}\n\n// 計算覆蓋率\nexport function calculateCoverage(gameState: GameState): number {\n  const { currentLevel, coveredCells } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  \n  return Math.round((coveredCells.size / targetCells) * 100);\n}\n\n// 計算星級評分\nexport function calculateStarRating(gameState: GameState): { stars: 1 | 2 | 3; description: string } {\n  const { currentLevel, currentTurn } = gameState;\n  const { minSteps } = currentLevel;\n  \n  const movesUsed = currentTurn - 1; // 因為 currentTurn 是下一回合的數字\n  \n  if (movesUsed <= minSteps + 1) {\n    return { stars: 3, description: '完美！' };\n  } else if (movesUsed <= minSteps + 5) {\n    return { stars: 2, description: '很好！' };\n  } else {\n    return { stars: 1, description: '完成！' };\n  }\n}\n\n// 初始化遊戲狀態\nexport function initializeGameState(level: Level): GameState {\n  const initialCoveredCells = new Set<string>();\n  \n  // 初始方塊位置視為已覆蓋\n  level.blocks.forEach(block => {\n    initialCoveredCells.add(positionToKey(block));\n  });\n  \n  return {\n    currentLevel: level,\n    blockPositions: [...level.blocks],\n    coveredCells: initialCoveredCells,\n    currentTurn: 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: [level.blocks]\n  };\n}\n\n// 撤銷移動\nexport function undoMove(gameState: GameState): GameState {\n  if (gameState.moveHistory.length <= 1) {\n    return gameState; // 無法撤銷\n  }\n  \n  const newMoveHistory = gameState.moveHistory.slice(0, -1);\n  const previousPositions = newMoveHistory[newMoveHistory.length - 1];\n  \n  // 重新計算覆蓋的格子\n  const newCoveredCells = new Set<string>();\n  previousPositions.forEach(pos => {\n    newCoveredCells.add(positionToKey(pos));\n  });\n  \n  return {\n    ...gameState,\n    blockPositions: previousPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: gameState.currentTurn - 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: newMoveHistory\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
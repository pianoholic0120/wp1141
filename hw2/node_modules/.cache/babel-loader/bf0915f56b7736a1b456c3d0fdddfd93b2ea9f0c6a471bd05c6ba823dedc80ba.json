{"ast":null,"code":"// 方向向量\nconst DIRECTION_VECTORS = {\n  up: {\n    row: -1,\n    col: 0\n  },\n  down: {\n    row: 1,\n    col: 0\n  },\n  left: {\n    row: 0,\n    col: -1\n  },\n  right: {\n    row: 0,\n    col: 1\n  }\n};\n\n// 將位置轉換為字串 key\nexport function positionToKey(pos) {\n  return `${pos.row},${pos.col}`;\n}\n\n// 將字串 key 轉換為位置\nexport function keyToPosition(key) {\n  const [row, col] = key.split(',').map(Number);\n  return {\n    row,\n    col\n  };\n}\n\n// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos, gridSize) {\n  return pos.row >= 0 && pos.row < gridSize[0] && pos.col >= 0 && pos.col < gridSize[1];\n}\n\n// 檢查位置是否為障礙物\nexport function isObstacle(pos, obstacles) {\n  return obstacles.some(obs => obs.row === pos.row && obs.col === pos.col);\n}\n\n// 根據方向排序方塊位置（用於確定移動順序）\nexport function sortPositionsByDirection(positions, direction) {\n  const sorted = [...positions];\n  switch (direction) {\n    case 'left':\n      // 從左到右（欄位座標由小到大）\n      return sorted.sort((a, b) => a.col - b.col);\n    case 'right':\n      // 從右到左（欄位座標由大到小）\n      return sorted.sort((a, b) => b.col - a.col);\n    case 'up':\n      // 從上到下（行座標由小到大）\n      return sorted.sort((a, b) => a.row - b.row);\n    case 'down':\n      // 從下到上（行座標由大到小）\n      return sorted.sort((a, b) => b.row - a.row);\n    default:\n      return sorted;\n  }\n}\n\n// 計算方塊在指定方向能移動到的位置，並返回經過的所有格子\nexport function calculateBlockMovement(startPos, direction, gridSize, obstacles, stoppedPositions) {\n  const vector = DIRECTION_VECTORS[direction];\n  let currentPos = {\n    ...startPos\n  };\n  const pathCells = [{\n    ...startPos\n  }]; // 包含起始位置\n\n  while (true) {\n    const nextPos = {\n      row: currentPos.row + vector.row,\n      col: currentPos.col + vector.col\n    };\n\n    // 檢查是否超出地圖範圍\n    if (!isPositionValid(nextPos, gridSize)) {\n      break;\n    }\n\n    // 檢查是否撞到固定障礙物\n    if (isObstacle(nextPos, obstacles)) {\n      break;\n    }\n\n    // 檢查是否撞到已停下的方塊\n    if (stoppedPositions.has(positionToKey(nextPos))) {\n      break;\n    }\n    currentPos = nextPos;\n    pathCells.push({\n      ...currentPos\n    });\n  }\n  return {\n    finalPosition: currentPos,\n    pathCells\n  };\n}\n\n// 執行一次移動\nexport function executeMove(gameState, direction) {\n  const {\n    currentLevel,\n    blockPositions,\n    coveredCells,\n    currentTurn\n  } = gameState;\n  const {\n    gridSize,\n    obstacles\n  } = currentLevel;\n\n  // 建立固定障礙物集合\n  const staticObstacles = obstacles;\n\n  // 根據方向排序方塊\n  const sortedPositions = sortPositionsByDirection(blockPositions, direction);\n\n  // 追蹤已停下的方塊位置\n  const stoppedPositions = new Set();\n  const newPositions = [];\n  const allPathCells = new Set(); // 收集所有經過的格子\n\n  // 按順序處理每個方塊\n  for (const originalPos of sortedPositions) {\n    const movement = calculateBlockMovement(originalPos, direction, gridSize, staticObstacles, stoppedPositions);\n\n    // 記錄最終位置\n    newPositions.push(movement.finalPosition);\n    stoppedPositions.add(positionToKey(movement.finalPosition));\n\n    // 記錄所有經過的格子\n    movement.pathCells.forEach(cell => {\n      allPathCells.add(positionToKey(cell));\n    });\n  }\n\n  // 更新覆蓋的格子 - 包含所有經過的路徑\n  const newCoveredCells = new Set(coveredCells);\n  allPathCells.forEach(cellKey => {\n    newCoveredCells.add(cellKey);\n  });\n\n  // 檢查是否勝利\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  const isGameWon = newCoveredCells.size >= targetCells;\n\n  // 檢查是否失敗\n  const isGameLost = !isGameWon && currentTurn >= currentLevel.turnLimit;\n\n  // 更新移動歷史\n  const newMoveHistory = [...gameState.moveHistory, newPositions];\n  return {\n    ...gameState,\n    blockPositions: newPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: currentTurn + 1,\n    isGameWon,\n    isGameLost,\n    moveHistory: newMoveHistory\n  };\n}\n\n// 計算覆蓋率\nexport function calculateCoverage(gameState) {\n  const {\n    currentLevel,\n    coveredCells\n  } = gameState;\n  const {\n    gridSize,\n    obstacles\n  } = currentLevel;\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  return Math.round(coveredCells.size / targetCells * 100);\n}\n\n// 計算星級評分\nexport function calculateStarRating(gameState) {\n  const {\n    currentLevel,\n    currentTurn\n  } = gameState;\n  const {\n    minSteps\n  } = currentLevel;\n  const movesUsed = currentTurn - 1; // 因為 currentTurn 是下一回合的數字\n\n  if (movesUsed <= minSteps + 1) {\n    return {\n      stars: 3,\n      description: '完美！'\n    };\n  } else if (movesUsed <= minSteps + 5) {\n    return {\n      stars: 2,\n      description: '很好！'\n    };\n  } else {\n    return {\n      stars: 1,\n      description: '完成！'\n    };\n  }\n}\n\n// 初始化遊戲狀態\nexport function initializeGameState(level) {\n  const initialCoveredCells = new Set();\n\n  // 初始方塊位置視為已覆蓋\n  level.blocks.forEach(block => {\n    initialCoveredCells.add(positionToKey(block));\n  });\n  return {\n    currentLevel: level,\n    blockPositions: [...level.blocks],\n    coveredCells: initialCoveredCells,\n    currentTurn: 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: [level.blocks]\n  };\n}\n\n// 撤銷移動\nexport function undoMove(gameState) {\n  if (gameState.moveHistory.length <= 1) {\n    return gameState; // 無法撤銷\n  }\n  const newMoveHistory = gameState.moveHistory.slice(0, -1);\n  const previousPositions = newMoveHistory[newMoveHistory.length - 1];\n\n  // 重新計算覆蓋的格子\n  const newCoveredCells = new Set();\n  previousPositions.forEach(pos => {\n    newCoveredCells.add(positionToKey(pos));\n  });\n  return {\n    ...gameState,\n    blockPositions: previousPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: gameState.currentTurn - 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: newMoveHistory\n  };\n}","map":{"version":3,"names":["DIRECTION_VECTORS","up","row","col","down","left","right","positionToKey","pos","keyToPosition","key","split","map","Number","isPositionValid","gridSize","isObstacle","obstacles","some","obs","sortPositionsByDirection","positions","direction","sorted","sort","a","b","calculateBlockMovement","startPos","stoppedPositions","vector","currentPos","pathCells","nextPos","has","push","finalPosition","executeMove","gameState","currentLevel","blockPositions","coveredCells","currentTurn","staticObstacles","sortedPositions","Set","newPositions","allPathCells","originalPos","movement","add","forEach","cell","newCoveredCells","cellKey","totalCells","obstacleCount","length","targetCells","isGameWon","size","isGameLost","turnLimit","newMoveHistory","moveHistory","calculateCoverage","Math","round","calculateStarRating","minSteps","movesUsed","stars","description","initializeGameState","level","initialCoveredCells","blocks","block","undoMove","slice","previousPositions"],"sources":["/Users/arthurlin/Desktop/網服/wp1141/hw2/src/utils/GameLogic.ts"],"sourcesContent":["import { Position, Direction, GameState, Level, Block } from '../types/GameTypes';\n\n// 方向向量\nconst DIRECTION_VECTORS: Record<Direction, Position> = {\n  up: { row: -1, col: 0 },\n  down: { row: 1, col: 0 },\n  left: { row: 0, col: -1 },\n  right: { row: 0, col: 1 }\n};\n\n// 將位置轉換為字串 key\nexport function positionToKey(pos: Position): string {\n  return `${pos.row},${pos.col}`;\n}\n\n// 將字串 key 轉換為位置\nexport function keyToPosition(key: string): Position {\n  const [row, col] = key.split(',').map(Number);\n  return { row, col };\n}\n\n// 檢查位置是否在地圖範圍內\nexport function isPositionValid(pos: Position, gridSize: [number, number]): boolean {\n  return pos.row >= 0 && pos.row < gridSize[0] && pos.col >= 0 && pos.col < gridSize[1];\n}\n\n// 檢查位置是否為障礙物\nexport function isObstacle(pos: Position, obstacles: Position[]): boolean {\n  return obstacles.some(obs => obs.row === pos.row && obs.col === pos.col);\n}\n\n// 根據方向排序方塊位置（用於確定移動順序）\nexport function sortPositionsByDirection(positions: Position[], direction: Direction): Position[] {\n  const sorted = [...positions];\n  \n  switch (direction) {\n    case 'left':\n      // 從左到右（欄位座標由小到大）\n      return sorted.sort((a, b) => a.col - b.col);\n    case 'right':\n      // 從右到左（欄位座標由大到小）\n      return sorted.sort((a, b) => b.col - a.col);\n    case 'up':\n      // 從上到下（行座標由小到大）\n      return sorted.sort((a, b) => a.row - b.row);\n    case 'down':\n      // 從下到上（行座標由大到小）\n      return sorted.sort((a, b) => b.row - a.row);\n    default:\n      return sorted;\n  }\n}\n\n// 計算方塊在指定方向能移動到的位置，並返回經過的所有格子\nexport function calculateBlockMovement(\n  startPos: Position,\n  direction: Direction,\n  gridSize: [number, number],\n  obstacles: Position[],\n  stoppedPositions: Set<string>\n): { finalPosition: Position; pathCells: Position[] } {\n  const vector = DIRECTION_VECTORS[direction];\n  let currentPos = { ...startPos };\n  const pathCells: Position[] = [{ ...startPos }]; // 包含起始位置\n  \n  while (true) {\n    const nextPos: Position = {\n      row: currentPos.row + vector.row,\n      col: currentPos.col + vector.col\n    };\n    \n    // 檢查是否超出地圖範圍\n    if (!isPositionValid(nextPos, gridSize)) {\n      break;\n    }\n    \n    // 檢查是否撞到固定障礙物\n    if (isObstacle(nextPos, obstacles)) {\n      break;\n    }\n    \n    // 檢查是否撞到已停下的方塊\n    if (stoppedPositions.has(positionToKey(nextPos))) {\n      break;\n    }\n    \n    currentPos = nextPos;\n    pathCells.push({ ...currentPos });\n  }\n  \n  return {\n    finalPosition: currentPos,\n    pathCells\n  };\n}\n\n// 執行一次移動\nexport function executeMove(\n  gameState: GameState,\n  direction: Direction\n): GameState {\n  const { currentLevel, blockPositions, coveredCells, currentTurn } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  // 建立固定障礙物集合\n  const staticObstacles = obstacles;\n  \n  // 根據方向排序方塊\n  const sortedPositions = sortPositionsByDirection(blockPositions, direction);\n  \n  // 追蹤已停下的方塊位置\n  const stoppedPositions = new Set<string>();\n  const newPositions: Position[] = [];\n  const allPathCells = new Set<string>(); // 收集所有經過的格子\n  \n  // 按順序處理每個方塊\n  for (const originalPos of sortedPositions) {\n    const movement = calculateBlockMovement(\n      originalPos,\n      direction,\n      gridSize,\n      staticObstacles,\n      stoppedPositions\n    );\n    \n    // 記錄最終位置\n    newPositions.push(movement.finalPosition);\n    stoppedPositions.add(positionToKey(movement.finalPosition));\n    \n    // 記錄所有經過的格子\n    movement.pathCells.forEach(cell => {\n      allPathCells.add(positionToKey(cell));\n    });\n  }\n  \n  // 更新覆蓋的格子 - 包含所有經過的路徑\n  const newCoveredCells = new Set(coveredCells);\n  allPathCells.forEach(cellKey => {\n    newCoveredCells.add(cellKey);\n  });\n  \n  // 檢查是否勝利\n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  const isGameWon = newCoveredCells.size >= targetCells;\n  \n  // 檢查是否失敗\n  const isGameLost = !isGameWon && currentTurn >= currentLevel.turnLimit;\n  \n  // 更新移動歷史\n  const newMoveHistory = [...gameState.moveHistory, newPositions];\n  \n  return {\n    ...gameState,\n    blockPositions: newPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: currentTurn + 1,\n    isGameWon,\n    isGameLost,\n    moveHistory: newMoveHistory\n  };\n}\n\n// 計算覆蓋率\nexport function calculateCoverage(gameState: GameState): number {\n  const { currentLevel, coveredCells } = gameState;\n  const { gridSize, obstacles } = currentLevel;\n  \n  const totalCells = gridSize[0] * gridSize[1];\n  const obstacleCount = obstacles.length;\n  const targetCells = totalCells - obstacleCount;\n  \n  return Math.round((coveredCells.size / targetCells) * 100);\n}\n\n// 計算星級評分\nexport function calculateStarRating(gameState: GameState): { stars: 1 | 2 | 3; description: string } {\n  const { currentLevel, currentTurn } = gameState;\n  const { minSteps } = currentLevel;\n  \n  const movesUsed = currentTurn - 1; // 因為 currentTurn 是下一回合的數字\n  \n  if (movesUsed <= minSteps + 1) {\n    return { stars: 3, description: '完美！' };\n  } else if (movesUsed <= minSteps + 5) {\n    return { stars: 2, description: '很好！' };\n  } else {\n    return { stars: 1, description: '完成！' };\n  }\n}\n\n// 初始化遊戲狀態\nexport function initializeGameState(level: Level): GameState {\n  const initialCoveredCells = new Set<string>();\n  \n  // 初始方塊位置視為已覆蓋\n  level.blocks.forEach(block => {\n    initialCoveredCells.add(positionToKey(block));\n  });\n  \n  return {\n    currentLevel: level,\n    blockPositions: [...level.blocks],\n    coveredCells: initialCoveredCells,\n    currentTurn: 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: [level.blocks]\n  };\n}\n\n// 撤銷移動\nexport function undoMove(gameState: GameState): GameState {\n  if (gameState.moveHistory.length <= 1) {\n    return gameState; // 無法撤銷\n  }\n  \n  const newMoveHistory = gameState.moveHistory.slice(0, -1);\n  const previousPositions = newMoveHistory[newMoveHistory.length - 1];\n  \n  // 重新計算覆蓋的格子\n  const newCoveredCells = new Set<string>();\n  previousPositions.forEach(pos => {\n    newCoveredCells.add(positionToKey(pos));\n  });\n  \n  return {\n    ...gameState,\n    blockPositions: previousPositions,\n    coveredCells: newCoveredCells,\n    currentTurn: gameState.currentTurn - 1,\n    isGameWon: false,\n    isGameLost: false,\n    moveHistory: newMoveHistory\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}